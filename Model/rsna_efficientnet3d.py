# -*- coding: utf-8 -*-
"""rsna_efficientnet3d.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MWiVHoywux75_hCu_eIDg6vb2ee_eF1V
"""

#!pip install torchio
#!pip install pytorch-lightning
#!pip install git+https://github.com/shijianjian/EfficientNet-PyTorch-3D

# Mount to Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# Import packages
import sys
import pytorch_lightning as pl
import torch
from torch import nn
from efficientnet_pytorch_3d import EfficientNet3D

# %load_ext tensorboard

class Efficientnet3DModel(pl.LightningModule):
  def __init__(self):
    super().__init__()
    self.eff3d = EfficientNet3D.from_name("efficientnet-b0", override_params={'num_classes': 1}, in_channels=1)

  def forward(self, x):
    return self.eff3d(x)

  def configure_optimizers(self):
    optimizer = torch.optim.Adam(self.parameters(), lr=1e-3)
    return optimizer

  def training_step(self, batch, batch_idx):
    # Get inputs
    input_flair = batch['FLAIR']['data']
    input_t1w = batch['T1w']['data']
    input_t1wce = batch['T1wCE']['data']
    input_t2w = batch['T2w']['data']

    # Concat inputs
    ls_input = [input_flair, input_t1w, input_t1wce, input_t2w]
    input_cat = torch.cat(ls_input, dim=4)

    # Forward
    y_hat = self(input_cat)
    
    # Loss function
    y = batch['MGMT_value'].view(-1,1).float()
    loss_fn = torch.nn.BCEWithLogitsLoss()
    loss = loss_fn(y_hat, y)
    self.log('train_loss', loss, prog_bar=True)
    return loss

  def validation_step(self, batch, batch_idx):
    # Get inputs
    input_flair = batch['FLAIR']['data']
    input_t1w = batch['T1w']['data']
    input_t1wce = batch['T1wCE']['data']
    input_t2w = batch['T2w']['data']

    # Concat inputs
    ls_input = [input_flair, input_t1w, input_t1wce, input_t2w]
    input_cat = torch.cat(ls_input, dim=4)

    # Forward
    y_hat = self(input_cat)
    
    # Loss function
    y = batch['MGMT_value'].view(-1,1).float()
    loss_fn = torch.nn.BCEWithLogitsLoss()
    loss = loss_fn(y_hat, y)
    self.log('val_loss', loss, prog_bar=True)
    return loss

if __name__ == '__main__':

  # Load dataset
  sys.path.append('/content/drive/MyDrive/Colab Notebooks/RSNA/Dataset')

  from rsnapre_bbox_v2 import RSNAPre
  dataset = RSNAPre(data_dir='/content/drive/MyDrive/Data/rsna_practice')
  dataset.setup()
  train_loader = dataset.train_dataloader()
  val_loader = dataset.val_dataloader()

  model = Efficientnet3DModel()
  
  early_stopping = pl.callbacks.early_stopping.EarlyStopping(
    monitor='val_loss',
  )

  trainer = pl.Trainer(callbacks=[early_stopping])
  trainer.fit(model, dataset)

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir lightning_logs

